/*!
 *  Chinachu Common Module (node-chinachu-common)
 *
 *  Copyright (c) 2012 Yuki KAN and Chinachu Project Contributors
 *  http://chinachu.akkar.in/
**/
/*jslint node:true, nomen:true, plusplus:true, regexp:true, vars:true, continue:true */
'use strict';

var fs         = require('fs');
var crypto     = require('crypto');
var dateFormat = require('dateformat');
var child_process = require('child_process');
var string = require('string');

var execSync   = function (command) {
	try {
		return child_process.execSync(command, { encoding: 'utf8' });
	} catch (e) {
	}
};

exports.jsonWatcher = function (filepath, callback, option) {
	if (typeof option === 'undefined') { option = {}; }
	
	option.wait = option.wait || 1000;
	
	if (!fs.existsSync(filepath)) {
		if (option.create) {
			fs.writeFileSync(filepath, JSON.stringify(option.create));
		} else {
			callback('FATAL: `' + filepath + '` is not exists.', null, null);
			return;
		}
	}
	
	var data = null;
	
	var parse = function (err, json) {
		if (err) {
			callback('WARN: Failed to read `' + filepath + '`. (' + err + ')', null, null);
		} else {
			data = null;
			
			try {
				data = JSON.parse(json);
				callback(null, data, 'READ: `' + filepath + '` is updated.');
			} catch (e) {
				callback('WARN: `' + filepath + '` is invalid. (' + e + ')', null, null);
			}
		}
	};
	
	var timer = null;
	
	var read = function () {
		timer = null;
		
		fs.readFile(filepath, { encoding: 'utf8' }, parse);
	};
	
	if (option.now) { read(); }
	
	var onUpdated = function () {
		if (timer !== null) { clearTimeout(timer); }
		timer = setTimeout(read, option.wait);
	};
	fs.watch(filepath, onUpdated);
};

exports.getProgramById = function (id, array) {
	if (!array || array.length === 0) {
		return null;
	}
	
	if (array[0].programs) {
		array = (function () {
			var programs = [];
			
			array.forEach(function (ch) {
				programs = programs.concat(ch.programs);
			});
			
			return programs;
		}());
	}
	
	return (function () {
		var x = null;
		
		array.forEach(function (a) {
			if (a.id === id) { x = a; }
		});
		
		return x;
	}());
};

exports.existsTuner = function (tuners, type, callback) {
	
	process.nextTick(function () {
		callback(exports.existsTunerSync(tuners, type));
	});
};

exports.existsTunerSync = function (tuners, type) {
	
	var j, tuner, isExists = false;
	
	for (j = 0; tuners.length > j; j++) {
		tuner = tuners[j];
		tuner.n = j;
		
		if (tuner.types.indexOf(type) !== -1) {
			isExists = true;
			break;
		}
	}
	
	return isExists;
};

exports.getFreeTunerSync = function (tuners, type, isEpg, priority) {
	
	var j, exists, pid, tuner, freeTuner = null, tunerWillBeUnlocked = null;
	
	priority = priority || 0;
	
	for (j = 0; tuners.length > j; j++) {
		tuner = tuners[j];
		tuner.n = j;
		
		if (tuner.types.indexOf(type) === -1) {
			continue;
		}
		
		if (isEpg === true && tuner.noEpg === true) {
			continue;
		}
		
		if (fs.existsSync('./data/tuner.' + j + '.lock') === true) {
			pid = fs.readFileSync('./data/tuner.' + j + '.lock', { encoding: 'utf8' });
			pid = pid.trim();
			
			if (pid === '') {
				continue;
			}
			
			if (execSync('kill -0 ' + pid) !== '') {
				exports.unlockTunerSync(tuner);
				freeTuner = tuner;
				break;
			}
			
			if (fs.existsSync('./data/tuner.' + j + '.priority') === true) {
				var tunerPriority = fs.readFileSync('./data/tuner.' + j + '.priority', { encoding: 'utf8' });
				tunerPriority = tunerPriority.trim();
				
				// Seek the lowest priority
				if (priority > tunerPriority) {
					tunerWillBeUnlocked = tuner;
					if (tunerPriority === 0) {
						break;
					}
					priority = tunerPriority;
					continue;
				} else {
					continue;
				}
			}
		} else {
			freeTuner = tuner;
			break;
		}
	}
	
	if (tunerWillBeUnlocked !== null && freeTuner === null) {
		tuner = tunerWillBeUnlocked;
		pid = fs.readFileSync('./data/tuner.' + tuner.n + '.lock', { encoding: 'utf8' });
		pid = pid.trim();
			
		// force terminate the process
		execSync('kill -KILL ' + pid);
		try {
			// If cleanup is not completed
			exports.unlockTunerSync(tuner);
		} catch(e) {
		}
		freeTuner = tuner;
	}
	
	return freeTuner;
};

exports.lockTunerSync = function (tuner, priority) {
	try {
		priority = priority || 0;
		fs.writeFileSync('./data/tuner.' + tuner.n + '.priority', priority, { flag: 'wx' });
		return fs.writeFileSync('./data/tuner.' + tuner.n + '.lock', process.pid, { flag: 'wx' });
	} catch (e) {
		throw e;
	}
};

exports.unlockTuner = function (tuner, callback) {
	if (fs.existsSync('./data/tuner.' + tuner.n + '.priority')) {
		fs.unlinkSync('./data/tuner.' + tuner.n + '.priority');
	}
	fs.unlink('./data/tuner.' + tuner.n + '.lock', callback);
};

exports.unlockTunerSync = function (tuner, safe) {
	try {
		if (safe === true) {
			var pid = fs.readFileSync('./data/tuner.' + tuner.n + '.lock', { encoding: 'utf8' });
			if (pid !== '') {
				if (execSync('kill -0 ' + pid) === '') {
					return null;
				} else {
					if (fs.existsSync('./data/tuner.' + tuner.n + '.priority')) {
						fs.unlinkSync('./data/tuner.' + tuner.n + '.priority');
					}
					return fs.unlinkSync('./data/tuner.' + tuner.n + '.lock');
				}
			}
		}
		if (fs.existsSync('./data/tuner.' + tuner.n + '.priority')) {
			fs.unlinkSync('./data/tuner.' + tuner.n + '.priority');
		}
		return fs.unlinkSync('./data/tuner.' + tuner.n + '.lock');
	} catch (e) {
		throw e;
	}
};

exports.writeTunerPidSync = function (tuner, pid, priority) {
	try {
		priority = priority || 0;
		fs.writeFileSync('./data/tuner.' + tuner.n + '.priority', priority, { flag: 'w' });
		return fs.writeFileSync('./data/tuner.' + tuner.n + '.lock', pid, { flag: 'w' });
	} catch (e) {
		throw e;
	}
};

var Countdown = function (count, callback) {
	this.c = count;
	this.f = callback;
};

Countdown.prototype = {
	tick: function () {
		
		--this.c;
		
		if (this.c === 0) {
			this.f();
		}
		
		return this;
	}
};

exports.createCountdown = function (a, b) {
	return new Countdown(a, b);
};

exports.createTimeout = function (a, b) {
	return function () {
		return setTimeout(a, b);
	};
};

exports.formatRecordedName = function (program, name) {
	name = name.replace(/<([^>]+)>/g, function (z, a) {
		
		// date:
		if (a.match(/^date:.+$/) !== null) { return dateFormat(new Date(program.start), a.match(/:(.+)$/)[1]); }
		
		// id
		if (a.match(/^id$/) !== null) { return program.id; }
		
		// type
		if (a.match(/^type$/) !== null) { return program.channel.type; }
		
		// channel
		if (a.match(/^channel$/) !== null) { return program.channel.channel; }
		
		// channel-id
		if (a.match(/^channel-id$/) !== null) { return program.channel.id; }
		
		// channel-sid
		if (a.match(/^channel-sid$/) !== null) { return program.channel.sid; }
		
		// channel-name
		if (a.match(/^channel-name$/) !== null) { return exports.stripFilename(program.channel.name); }
		
		// tuner
		if (a.match(/^tuner$/) !== null) { return program.tuner.name; }
		
		// title
		if (a.match(/^title$/) !== null) { return exports.stripFilename(program.title); }
		
		// fulltitle
		if (a.match(/^fulltitle$/) !== null) { return exports.stripFilename(program.fullTitle || ''); }
		
		// subtitle
		if (a.match(/^subtitle$/) !== null) { return exports.stripFilename(program.subTitle || ''); }
		
		// episode (zero-padded)
		if (a.match(/^episode:\d+$/) !== null) {
			var digit = a.match(/\d+/)[0];
			if (isNaN(digit)) {
				digit = 1;
			}
			return program.episode === null ? 'n' : string(program.episode.toString(10)).padLeft(digit, '0').s;
		}

		// episode
		if (a.match(/^episode$/) !== null) { return program.episode || 'n'; }
		
		// category
		if (a.match(/^category$/) !== null) { return program.category; }
	});
	
	return name;
};

// strip
exports.stripFilename = function (a) {
	
	a = a.replace(/\//g, '／').replace(/\\/g, '＼').replace(/:/g, '：').replace(/\*/g, '＊').replace(/\?/g, '？');
	a = a.replace(/"/g, '”').replace(/</g, '＜').replace(/>/g, '＞').replace(/\|/g, '｜').replace(/≫/g, '＞＞');
	
	return a;
};

// 全ルールとのマッチ判定
exports.isMatchedProgram = function (rules, program, nf) {
	var i;

	// fullTitle, detailを正規化しておく。
	var fullTitle_norm, detail_norm;
	if (nf) {
		fullTitle_norm = program.fullTitle.normalize(nf);
		if (program.detail) {
			detail_norm = program.detail.normalize(nf);
		}
	}
	else {
		fullTitle_norm = program.fullTitle;
		if (program.detail) {
			detail_norm = program.detail;
		}
	}
	for (i = 0; i < rules.length; i++) {
		if (exports.programMatchesRule(rules[i], program, nf, fullTitle_norm, detail_norm)) {
			return true;
		}
	}

	return false;
};

// 単体のルールとのマッチ判定
exports.programMatchesRule = function (rule, program, nf, fullTitle_norm, detail_norm) {
	var i, j, l, m, isFound;

	// 引数に互換性を持たせるため、追加した分はチェック
	// タイトル、詳細
	if (nf) {
		if (!fullTitle_norm) {
			fullTitle_norm = program.fullTitle.normalize(nf);
		}
		if (!detail_norm) {
			detail_norm = program.detail.normalize(nf);
		}
	}

	// isDisabled
	if (rule.isDisabled) { return false; }

	// sid
	if (rule.sid && rule.sid !== program.channel.sid) { return false; }

	// types
	if (rule.types) {
		if (rule.types.indexOf(program.channel.type) === -1) { return false; }
	}

	// channels
	if (rule.channels) {
		if (rule.channels.indexOf(program.channel.id) === -1) {
			if (rule.channels.indexOf(program.channel.channel) === -1) {
				return false;
			}
		}
	}

	// ignore_channels
	if (rule.ignore_channels) {
		if (rule.ignore_channels.indexOf(program.channel.id) !== -1) {
			return false;
		}
		if (rule.ignore_channels.indexOf(program.channel.channel) !== -1) {
			return false;
		}
	}

	// category
	if (rule.category && rule.category !== program.category) { return false; }

	// categories
	if (rule.categories) {
		if (rule.categories.indexOf(program.category) === -1) { return false; }
	}

	// hour
	if (rule.hour && (typeof rule.hour.start === 'number') && (typeof rule.hour.end === 'number') && !(rule.hour.start === 0 && rule.hour.end === 24)) {
		var ruleStart = rule.hour.start;
		var ruleEnd   = rule.hour.end;

		var progStart = new Date(program.start).getHours();
		var progEnd   = new Date(program.end).getHours();
		var progEndMinute = new Date(program.end).getMinutes();

		if (progStart > progEnd) {
			progEnd += 24;
		}
		if (progEndMinute === 0) {
			progEnd -= 1;
		}

		if (ruleStart > ruleEnd) {
			if ((ruleStart > progStart) && (ruleEnd < progEnd)) { return false; }
		} else {
			if ((ruleStart > progStart) || (ruleEnd < progEnd)) { return false; }
		}
	}

	// duration
	if (rule.duration && (typeof rule.duration.min !== 'undefined') && (typeof rule.duration.max !== 'undefined')) {
		if ((rule.duration.min > program.seconds) || (rule.duration.max < program.seconds)) { return false; }
	}

	// reserve_titles
	if (rule.reserve_titles) {
		isFound = false;

		for (i = 0; i < rule.reserve_titles.length; i++) {
			if (fullTitle_norm === null) {
				console.log("program: " + JSON.stringify(program));
			}
			if (nf) {
				if (fullTitle_norm.match(rule.reserve_titles[i].normalize(nf)) !== null) { isFound = true; }
			}
			else {
				if (program.fullTitle.match(rule.reserve_titles[i]) !== null) { isFound = true; }
			}
		}

		if (!isFound) { return false; }
	}

	// ignore_titles
	if (rule.ignore_titles) {
		for (i = 0; i < rule.ignore_titles.length; i++) {
			if (nf) {
				if (fullTitle_norm.match(rule.ignore_titles[i].normalize(nf)) !== null) { return false; }
			}
			else {
				if (program.fullTitle.match(rule.ignore_titles[i]) !== null) { return false; }
			}
		}
	}

	// reserve_descriptions
	if (rule.reserve_descriptions) {
		if (!program.detail) { return false; }

		isFound = false;

		for (i = 0; i < rule.reserve_descriptions.length; i++) {
			if (nf) {
				if (detail_norm.match(rule.reserve_descriptions[i].normalize(nf)) !== null) { isFound = true; }
			}
			else {
				if (program.detail.match(rule.reserve_descriptions[i]) !== null) { isFound = true; }
			}
		}

		if (!isFound) { return false; }
	}

	// ignore_descriptions
	if (rule.ignore_descriptions) {
		if (!program.detail) { return false; }

		for (i = 0; i < rule.ignore_descriptions.length; i++) {
			if (nf) {
				if (detail_norm.match(rule.ignore_descriptions[i].normalize(nf)) !== null) { return false; }
			}
			else {
				if (program.detail.match(rule.ignore_descriptions[i]) !== null) { return false; }
			}
		}
	}

	// ignore_flags
	if (rule.ignore_flags) {
		for (i = 0; i < rule.ignore_flags.length; i++) {
			for (j = 0; j < program.flags.length; j++) {
				if (rule.ignore_flags[i] === program.flags[j]) { return false; }
			}
		}
	}

	// reserve_flags
	if (rule.reserve_flags) {
		if (!program.flags) { return false; }

		isFound = false;

		for (i = 0; i < rule.reserve_flags.length; i++) {
			for (j = 0; j < program.flags.length; j++) {
				if (rule.reserve_flags[i] === program.flags[j]) { isFound = true; }
			}
		}

		if (!isFound) { return false; }
	}

	return true;
};

// (function) program converter
exports.convertPrograms = function (p, ch) {
	var programs = [];

	var i, l;
	for (i = 0, l = p.length; i < l; i++) {
		var j, m;
		var c = p[i];

		if (c.$.channel !== ch.id || !c.title[0]._) {
			continue;
		}

		var title = c.title[0]._;

		title = title
			.replace(/【.{1,2}】/g, '')
			.replace(/\[.\]/g, '')
			.replace(/[「（#＃♯第]+[0-9０-９零一壱壹弌二弐貮貳三参參弎四肆五伍六陸七柒漆八捌九玖十拾廿卄]+[話回」）]*/g, '');

		if (c.category[1]._ === 'anime') {
			title = title.replace(/(?:TV|ＴＶ)?アニメ「([^「」]+)」/g, '$1');
		}

		title = title.trim();

		var desc = c.desc[0]._ || '';

		var subtitle = '';
		if (c.title[0]._.match(/[^版]「([^「」]+)」/) !== null) {
			subtitle = c.title[0]._.match(/[^版]「([^「」]+)」/)[1];
		} else if (desc.match(/「([^「」]+)」/) !== null) {
			subtitle = desc.match(/「([^「」]+)」/)[1];
		} else if (desc.match(/『([^『』]+)』/) !== null) {
			subtitle = desc.match(/『([^『』]+)』/)[1];
		}

		var flags = [];
		var flagsSource = c.title[0]._
			.replace(/【/g, '[')
			.replace(/】/g, ']')
			.replace(/\[無料\]/g, '[無]');
		var matchedFlags = (flagsSource.match(/\[(.)\]/g) || []);
		for (j = 0, m = matchedFlags.length; j < m; j++) {
			flags.push(matchedFlags[j].match(/(?:【|\[)(.)(?:】|\])/)[1]);
		}

		var episodeNumber = null;
		var episodeNumberMatch = (c.title[0]._ + ' ' + desc).match(/[「（#＃♯第]+[0-9０-９零一壱壹弌二弐貮貳三参參弎四肆五伍六陸七柒漆八捌九玖十拾廿卄]+[話回」）]*|Episode ?[IⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫVX]+/);
		if (episodeNumberMatch !== null) {
			var episodeNumberString = episodeNumberMatch[0];

			episodeNumberString = episodeNumberString
				.replace(/「|（|#|＃|♯|第|話|回|」|）/g, '')
				.replace(/０|零/g, '0')
				.replace(/４|Ⅳ|IV|ＩＶ/g, '4')
				.replace(/８|Ⅷ|VIII|ＶＩＩＩ/g, '8')
				.replace(/７|Ⅶ|VII|ＶＩＩ/g, '7')
				.replace(/６|Ⅵ|VI|ＶＩ/g, '6')
				.replace(/５|Ⅴ/g, '5')
				.replace(/９|Ⅸ|IX|ＩＸ/g, '9')
				.replace(/Ⅻ|XII|ＸＩＩ/g, '12')
				.replace(/Ⅺ|XI|ＸＩ/g, '11')
				.replace(/３|Ⅲ|III|ＩＩＩ/g, '3')
				.replace(/２|Ⅱ|II|ＩＩ/g, '2')
				.replace(/１|Ⅰ|I|Ｉ/g, '1')
				.replace(/Ⅹ|X|Ｘ/g, '10')
				.replace(/廿|卄/g, '二十')
				.replace(/拾/g, '十')
				.replace(/壱|壹|弌/g, '一')
				.replace(/弐|貮|貳/g, '二')
				.replace(/参|參|弎/g, '三')
				.replace(/肆/g, '四')
				.replace(/伍/g, '五')
				.replace(/陸/g, '六')
				.replace(/柒|漆/g, '七')
				.replace(/捌/g, '八')
				.replace(/玖/g, '九')
				.replace(/二十一/g, '21')
				.replace(/二十二/g, '22')
				.replace(/二十三/g, '23')
				.replace(/二十四/g, '24')
				.replace(/二十/g, '20')
				.replace(/十一/g, '11')
				.replace(/十二/g, '12')
				.replace(/十三/g, '13')
				.replace(/十四/g, '14')
				.replace(/十五/g, '15')
				.replace(/十六/g, '16')
				.replace(/十七/g, '17')
				.replace(/十八/g, '18')
				.replace(/十九/g, '19')
				.replace(/十/g, '10')
				.replace(/一/g, '1')
				.replace(/二/g, '2')
				.replace(/三/g, '3')
				.replace(/四/g, '4')
				.replace(/五/g, '5')
				.replace(/六/g, '6')
				.replace(/七/g, '7')
				.replace(/八/g, '8')
				.replace(/九/g, '9')
				.trim();

			episodeNumber = parseInt(episodeNumberString, 10);
		}
		if (episodeNumber === null && flags.indexOf('新') !== -1) {
			episodeNumber = 1;
		}

		var tcRegex   = /^(.{4})(.{2})(.{2})(.{2})(.{2})(.{2}).+$/;
		var startDate = new Date(c.$.start.replace(tcRegex, '$1/$2/$3 $4:$5:$6'));
		var endDate   = new Date(c.$.stop.replace(tcRegex, '$1/$2/$3 $4:$5:$6'));
		var startTime = startDate.getTime();
		var endTime   = endDate.getTime();

		// 番組ID (v1.3)
		var programId = '';
		programId += ch.id.toLowerCase().replace('_', '');
		programId += '-';
		programId += parseInt(c.$.event_id, 10).toString(36);

		var programData = {
			id        : programId,
			channel   : ch,
			category  : c.category[1]._,
			title     : title,
			subTitle  : subtitle,
			fullTitle : c.title[0]._,
			detail    : desc,
			episode   : episodeNumber,
			start     : startTime,
			end       : endTime,
			seconds   : ((endTime - startTime) / 1000),
			flags     : flags
		};

		programs.push(programData);
	}

	return programs;
};
